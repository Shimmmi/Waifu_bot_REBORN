# Базы предметов + аффиксы/суффиксы “параллельными линиями” (следующий шаг)

## Предложение решения

Подождите, дайте проверю: ваша мысль “меч-1 и топор-1 одного уровня N, меч-2 и посох-2 одного уровня M” означает, что **уровень задаётся tier’ом**, а не типом предмета. То же самое для аффиксов: “+2 к СИЛ” и “+2 к ИНТ” должны давать **одинаковый вклад в уровень предмета**.

Чтобы это работало предсказуемо, предлагаю 3 слоя:

### Слой A — Базовый уровень по tier (общий для всех базовых предметов этого tier)

- Для каждого `base_tier = 1..10` задаём “канонический” `base_level`.
- Все базы данного tier (меч/tопор/посох/кольцо/…) имеют **одинаковый** `base_level`.

### Слой B — “Вклад в уровень” от аффикса зависит от величины ролла

О, я упустил важное в прошлом документе: вам нужно, чтобы **один и тот же аффикс** при ролле `+2` давал N уровень, а при ролле `+3` — N+1. Это значит:

> `affix_level_delta` должен зависеть от `rolled_value`.

Самый простой и стабильный вариант:

**Формула:**

`affix_level_delta = tier_delta_base(tier) + (rolled_value - value_min)`

Для примера “Мощный: +2..3 СИЛ”:
- при +2 → `affix_level_delta = base + 0`
- при +3 → `affix_level_delta = base + 1`

### Слой C — total_level

`total_level = base_level + Σ affix_level_delta + sharpen_level_delta`

Где `sharpen_level_delta` пока 0 (перспектива).

---

## Жёсткая критика (слабые места)

1) **Риск “переусиления” диапазонов.** Если `tier_delta_base` слишком большой, любой предмет будет улетать в капы актов, и система “добора (18–20)-base_level” станет бессмысленной.

2) **Невыполнимые цели.** Если у вас цели вида “18–20”, а аффиксы дают только `+0..1`, то вы никогда не доберёте нужный `delta`. Нужно контролировать “покрытие” (можно ли собрать дельту 8..10 разумным числом аффиксов).

3) **Стабильность названий.** Если один и тот же аффикс “Мощный” может быть и +2 (уровень N) и +3 (уровень N+1), то **название одинаковое**, а “уровень сильнее” — только цифры. Это нормально, но если захотите “Мощный/Очень мощный” внутри одного tier — это отдельный слой (не обязателен).

4) **Совместимость с текущим генератором.** Сейчас генерация предметов в `ItemService.generate_inventory_item` выбирает `level` “как уровень предмета” и вычисляет `tier` от него. Это не 1:1 с вашей моделью (у вас level = total_level). Значит сначала мы фиксируем таблицы (этот документ), а потом переделываем генератор под `base_level/total_level`.

---

## Финальный ответ: конкретные таблицы (каркас, который можно заполнять)

### 1) Таблица tier → базовый уровень (общий для всех баз этого tier)

Подход: “уровень tier’а — это нижняя граница пятёрки”.

| base_tier | base_level (N) | типичный диапазон total_level в tier (без заточки) |
|---:|---:|---|
| 1 | 1 | 1..5 |
| 2 | 6 | 6..10 |
| 3 | 11 | 11..15 |
| 4 | 16 | 16..20 |
| 5 | 21 | 21..25 |
| 6 | 26 | 26..30 |
| 7 | 31 | 31..35 |
| 8 | 36 | 36..40 |
| 9 | 41 | 41..45 |
| 10 | 46 | 46..50 |

> Если хотите чтобы “топор tier2 базово 10 уровня” — это можно, но тогда tier2 уже “10..14”, и вся сетка съезжает. Я сознательно беру **нижнюю границу**, потому что это идеально стыкуется с актами и “18–20”.

### 2) Таблица базовых предметов (параллельные линейки по tier)

Заполняем по tier: `меч-{tier}`, `топор-{tier}`, `посох-{tier}`, …

| base_key | display_name_ru | slot_type | weapon_type | attack_type | base_tier | base_level (=таблица выше) | dmg_min | dmg_max | attack_speed | notes |
|---|---|---|---|---|---:|---:|---:|---:|---:|---|
| sword-1 | меч-1 | weapon_1h | sword | melee | 1 | 1 |  |  |  | |
| axe-1 | топор-1 | weapon_1h | axe | melee | 1 | 1 |  |  |  | |
| staff-1 | посох-1 | weapon_2h | staff | magic | 1 | 1 |  |  |  | |
| bow-1 | лук-1 | weapon_2h | bow | ranged | 1 | 1 |  |  |  | |
| ring-1 | кольцо-1 | ring |  |  | 1 | 1 |  |  |  | |
| amulet-1 | амулет-1 | amulet |  |  | 1 | 1 |  |  |  | |
| costume-1 | костюм-1 | costume |  |  | 1 | 1 |  |  |  | |
| offhand-1 | щит-1 | offhand | shield | melee | 1 | 1 |  |  |  | |
| sword-2 | меч-2 | weapon_1h | sword | melee | 2 | 6 |  |  |  | |
| axe-2 | топор-2 | weapon_1h | axe | melee | 2 | 6 |  |  |  | |
| staff-2 | посох-2 | weapon_2h | staff | magic | 2 | 6 |  |  |  | |
| … | … | … | … | … | … | … | … | … | … | … |
| sword-10 | меч-10 | weapon_1h | sword | melee | 10 | 46 |  |  |  | |

### 3) Таблица аффиксов (параллельные линейки по stat)

Ключевая идея: “+2 СИЛ” и “+2 ИНТ” → одинаковый `affix_level_delta`.

#### 3.1 Нормирование “силы” аффикса по tier

Для первичных статов (strength/agility/intelligence/endurance/charm/luck) задаём одинаковые диапазоны значений **по tier**:

| tier | value_min..value_max (для первичных статов) |
|---:|---|
| 1 | +1..+2 |
| 2 | +2..+3 |
| 3 | +3..+5 |
| 4 | +5..+7 |
| 5 | +7..+10 |
| 6 | +10..+13 |
| 7 | +13..+17 |
| 8 | +17..+22 |
| 9 | +22..+26 |
| 10 | +26..+30 |

> Это примерная сетка. Важно не конкретное число, а **параллельность** по характеристикам.

#### 3.2 Вклад в уровень от аффикса

Определяем базовую часть по tier:

| tier | tier_delta_base(tier) |
|---:|---:|
| 1 | 0 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 4 |
| 6 | 5 |
| 7 | 6 |
| 8 | 7 |
| 9 | 8 |
| 10 | 9 |

**Итоговая формула для первичных статов:**

`affix_level_delta = tier_delta_base(tier) + (rolled_value - value_min)`

Пример для tier2 (+2..+3):
- +2 → 1 + 0 = +1 уровня
- +3 → 1 + 1 = +2 уровня

#### 3.3 Таблица аффиксов (шаблон строк)

| affix_key | name_ru | kind | stat | tier | value_min | value_max | tier_delta_base | applies_to |
|---|---|---|---|---:|---:|---:|---:|---|
| a_str_2 | Мощный | affix | strength | 2 | 2 | 3 | 1 | any |
| a_int_2 | Мудрый | affix | intelligence | 2 | 2 | 3 | 1 | any |
| a_end_2 | Крепкий | affix | endurance | 2 | 2 | 3 | 1 | any |
| a_luck_2 | Удачливый | affix | luck | 2 | 2 | 3 | 1 | any |
| a_cha_2 | Очаровательный | affix | charm | 2 | 2 | 3 | 1 | ring,amulet,costume |

### 4) Суффиксы “семействами” (одна механика, разные имена по tier)

Пример: нежить (undead). Суффикс не “числом” увеличивает уровень предмета напрямую, а через `affix_level_delta` так же, как аффикс.

| family_key | tier | name_ru | kind | stat | value_min..max | tier_delta_base |
|---|---:|---|---|---|---|---:|
| f_undead | 2 | убийцы нежити | suffix | damage_vs_monster_type_flat:undead | 2..4 | 1 |
| f_undead | 4 | карателя нежити | suffix | damage_vs_monster_type_flat:undead | 5..8 | 3 |
| f_undead | 6 | истребителя нежити | suffix | damage_vs_monster_type_flat:undead | 9..13 | 5 |
| f_undead | 8 | уничтожителя нежити | suffix | damage_vs_monster_type_flat:undead | 14..19 | 7 |
| f_undead | 10 | супер‑пупер убивателя нежити | suffix | damage_vs_monster_type_flat:undead | 20..30 | 9 |

> Здесь `tier_delta_base` можно оставить тем же, что и для статов, а рост “силы” идёт через `value_min..max`.

---

## Что делать дальше (очень конкретно)

1) Заполнить таблицу баз (B) для tier 1..10 хотя бы по 4–6 типам (меч/топор/посох/лук/кольцо/амулет).
2) Заполнить таблицу аффиксов (C) для 6 статов по tier 1..10 по одной строке на stat×tier.
3) Поддержать `level_delta` в данных (сейчас в `Affix` его нет) — это отдельная миграция/расширение модели.
4) Переписать генерацию предметов так, чтобы:
   - выбирать базу по `base_tier/base_level`,
   - добирать `total_level` через `Σ level_delta`.

Если хотите, я могу сразу сделать следующий практический шаг: сгенерировать вам “готовые к копипасте” строки для tier 1..10 по 6 статам (60 строк) и базовые предметы (например 40–60 строк) прямо в этом формате. Все будут параллельны и согласованы.```python
